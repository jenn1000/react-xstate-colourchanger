{"version":3,"sources":["srgs.js","chartparser.js","dmSmartHome.ts","index.tsx"],"names":["Repeat","min","max","sequence","RepeatClass","RefClass","ruleref","this","content","_string","toString","TagClass","tag","OneOfClass","alternatives","join","Infinity","throwRuleError","message","error","undefined","TypeError","checkSequenceExpansion","i","constructor","Array","name","String","checkExpansion","err","prototype","Number","LOG","str","clone","obj","temp","key","isEmpty","ob","hasOwnProperty","Chart","numberOfWords","passives","actives","add","edge","subchart","cat","isPassive","start","lhs","end","next","resultsForRule","results","finalEdges","push","out","allEdges","allPassiveEdges","concat","allActiveEdges","edges","j","k","statistics","length","nrEdges","nrPassiveEdges","nrActiveEdges","PassiveEdge","ActiveEdge","rest","rules","text","parse","words","grammar","root","filter","$root","chart","agenda","leftCornerFilter","addToChart","inference","rhs","slice","SRGS","oneof","eval","position","leftCorners","pop","active","ref","passive","parsing","split","gram","dmMachine","initial","states","init","on","CLICK","welcome","RECOGNISED","cond","context","recResult","target","actions","assign","option","prompt","entry","send","_context","type","value","ENDSPEECH","ask","promptAndAsk","returnobject","combine","object","action","inspect","url","iframe","machine","Machine","id","dm","asrtts","idle","LISTEN","SPEAK","event","ttsAgenda","recognising","exit","ASRRESULT","progress","match","speaking","recLogResult","console","log","test","logIntent","nluData","intent","ReactiveButton","props","state","matches","className","style","animation","App","useSpeechSynthesis","onEnd","speak","cancel","useSpeechRecognition","onResult","result","listen","stop","listening","useMachine","devTools","recStart","asEffect","interimResults","continuous","recStop","changeColour","document","body","background","ttsStart","effect","ttsCancel","current","onClick","rootElement","getElementById","ReactDOM"],"mappings":"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","file":"static/js/main.c053b7a4.chunk.js","sourcesContent":["//\r\n//  srgs.js\r\n//  Copyright (C) 2009, Peter Ljunglöf. All rights reserved.\r\n//\r\n/*\r\n  This program is free software: you can redistribute it and/or modify\r\n  it under the terms of the GNU Lesser General Public License as published \r\n  by the Free Software Foundation, either version 3 of the License, or\r\n  (at your option) any later version.\r\n  \r\n  This program is distributed in the hope that it will be useful,\r\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n  GNU General Public License for more details.\r\n  \r\n  You should have received a copy of the GNU General Public License\r\n  and the GNU Lesser General Public License along with this program.  \r\n  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// encoding SRGS grammars in javascript\r\n\r\nexport function Grammar(root) {\r\n  this.$root = root;\r\n  \r\n  this.VOID = [OneOf([])];\r\n  this.NULL = [];\r\n  this.GARBAGE = []; \r\n  \r\n  this.$check = function() {\r\n    for (var i in this) {\r\n      if (i !== \"$root\" && i !== \"$check\") {\r\n\ttry {\r\n\t  checkSequenceExpansion(this[i]);\r\n\t} catch(err) {\r\n\t  throwRuleError(\"When checking grammar rule '\" + i + \"'\", err);\r\n\t}\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function WordSet(str) {\r\n  var words = str.split(/ +/);\r\n  var set = {};\r\n  for (var i in words) {\r\n    set[words[i]] = true;\r\n  }\r\n  return set;\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// rule expansion constructors\r\n\r\n// sequences are ordinary arrays\r\nexport function Sequence(seq) {\r\n  return seq;\r\n}\r\n\r\nexport function Ref(ref) {\r\n  return new RefClass(ref);\r\n}\r\n\r\nexport function Tag(tag) {\r\n  return new TagClass(tag);\r\n}\r\n\r\nexport function OneOf(alternatives) {\r\n  return new OneOfClass(alternatives);\r\n}\r\n\r\nexport function Repeat(min, max, sequence) {\r\n  return new RepeatClass(min, max, sequence);\r\n}\r\n\r\nexport function Optional(sequence) {\r\n  return new RepeatClass(0, 1, sequence);\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// rule expansion classes\r\n\r\nexport function RefClass(ruleref) {\r\n  this.content = ruleref;\r\n  this._string = \"$\" + ruleref;\r\n  this.toString = function toString() {return this._string}\r\n}\r\n    \r\nexport function TagClass(tag) {\r\n  this.content = tag;\r\n  this._string = \"{\" + tag + \"}\";\r\n  this.toString = function toString() {return this._string}\r\n}\r\n\r\nexport function OneOfClass(alternatives) {\r\n  this.content = alternatives;\r\n  this._string = \"(\" + alternatives.join(\"|\") + \")\";\r\n  this.toString = function toString() {return this._string}\r\n}\r\n\r\nexport function RepeatClass(min, max, sequence) {\r\n  this.min = min;\r\n  this.max = max;\r\n  this.content = sequence;\r\n  this._string = this.content + \"<\" + this.min + \"-\" + (this.max==Infinity ? \"\" : this.max) + \">\"\r\n  this.toString = function toString() {return this._string}\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// checking rule expansions\r\n\r\nexport function throwRuleError(message, error) {\r\n  if (error == undefined) {\r\n    throw TypeError(message);\r\n  } else {\r\n    throw TypeError(message + \"; \" + error.message);\r\n  }\r\n}\r\n\r\nexport function checkSequenceExpansion(sequence) {\r\n  try {\r\n    if (sequence.constructor !== Array) {\r\n      throwRuleError(\"Expected Array, found \" + sequence.constructor.name);\r\n    }\r\n    for (var i in sequence) {\r\n      if (sequence[i].constructor == Array) {\r\n\tcheckSequenceExpansion(sequence[i]);\r\n      } else if (sequence[i].constructor != String) {\r\n\tsequence[i].checkExpansion();\r\n      }\r\n    }\r\n  } catch(err) {\r\n    throwRuleError(\"When checking sequence expansion\", err);\r\n  }\r\n};\r\n\r\nRefClass.prototype.checkExpansion = function checkExpansion() {\r\n  if (this.content.constructor !== String) {\r\n    throwRuleError(\"When checking Ref content; Expected String, found \" + this.content.constructor.name);\r\n  }\r\n};\r\n\r\nTagClass.prototype.checkExpansion = function checkExpansion() {\r\n  if (this.content.constructor !== String) {\r\n      throwRuleError(\"When checking Tag content; Expected String, found \" + this.content.constructor.name);\r\n  }\r\n};\r\n\r\nOneOfClass.prototype.checkExpansion = function checkExpansion() {\r\n  try {\r\n    if (this.content.constructor !== Array) {\r\n      throwRuleError(\"Expected Array, found \" + this.content.constructor.name);\r\n    }\r\n    for (var i in this.content) {\r\n      checkSequenceExpansion(this.content[i]);\r\n    }\r\n  } catch(err) {\r\n    throwRuleError(\"When checking OneOf content\", err);\r\n  }\r\n};\r\n\r\nRepeatClass.prototype.checkExpansion = function checkExpansion() {\r\n  try {\r\n    if (this.min.constructor !== Number || this.max.constructor !== Number) {\r\n      throwRuleError(\"Expected min/max to be Number, found \" + this.min.constructor.name + \"/\" + this.max.constructor.name);\r\n    }\r\n    if (!(0 <= this.min && this.min <= this.max)) {\r\n      throwRuleError(\"Expected 0 <= min <= max, found \" + this.min + \"/\" + this.max);\r\n    }\r\n    checkSequenceExpansion(this.content);\r\n  } catch(err) {\r\n    throwRuleError(\"When checking Repeat content\", err);\r\n  }\r\n};\r\n\r\n","//\r\n//  chartparser.js\r\n//  Copyright (C) 2009, Peter Ljunglöf. All rights reserved.\r\n//\r\n/*\r\n  This program is free software: you can redistribute it and/or modify\r\n  it under the terms of the GNU Lesser General Public License as published \r\n  by the Free Software Foundation, either version 3 of the License, or\r\n  (at your option) any later version.\r\n  \r\n  This program is distributed in the hope that it will be useful,\r\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n  GNU General Public License for more details.\r\n  \r\n  You should have received a copy of the GNU General Public License\r\n  and the GNU Lesser General Public License along with this program.  \r\n  If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\n/* Mods by Torbjörn\r\n- Removed the toString() method from Object. Why does it still work?\r\n- Added a text variable (similar to rules). See \r\n*/\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// a logging function\r\n//  - uncomment if you want to debug the parsing process\r\nfunction LOG(str) {\r\n  //console.log(\"\" + str);\r\n}\r\n\r\nimport * as SRGS from './srgs'\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// we need to be able to clone objects between different edges\r\n// borrowed from http://keithdevens.com/weblog/archive/2007/Jun/07/javascript.clone\r\nfunction clone(obj){\r\n  if (obj == null || typeof(obj) != 'object') {\r\n    return obj;\r\n  }\r\n  var temp = new obj.constructor(); \r\n  for (var key in obj) {\r\n    temp[key] = clone(obj[key]);\r\n  }\r\n  return temp;\r\n}\r\n\r\n\r\nfunction isEmpty(ob){\r\n   for (var i in ob) { if(ob.hasOwnProperty(i)) {return false;}}\r\n  return true;\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// parse chart\r\n// conceptually this is a set of edges, but it is optimized\r\nfunction Chart(numberOfWords) {\r\n  this.numberOfWords = numberOfWords;\r\n  this.passives = new Array(numberOfWords);\r\n  this.actives = new Array(numberOfWords);\r\n  for (var i = 0; i <= numberOfWords; i++) {\r\n    this.passives[i] = {};\r\n    this.actives[i] = {};\r\n  }\r\n\r\n  // Chart.add(edge)\r\n  // add the edge to the chart, return true if the chart was changed \r\n  // (i.e. if the chart didn't already contain the edge)\r\n  this.add = function add(edge) {\r\n    var subchart, cat;\r\n    if (edge.isPassive) {\r\n      subchart = this.passives[edge.start];\r\n      cat = edge.lhs;\r\n    } else {\r\n      subchart = this.actives[edge.end];\r\n      cat = edge.next.content;\r\n    }\r\n    if (!(cat in subchart)) {\r\n      subchart[cat] = {};\r\n    }\r\n    if (edge in subchart[cat]) {\r\n      return false;\r\n    } else {\r\n      subchart[cat][edge] = edge;\r\n      return true;\r\n    }\r\n  }\r\n\r\n  // Chart.resultsForRule(lhs, start, end)\r\n  // return all parse results for the given lhs, start, and end\r\n  //  - start, end are optional; defaults to 0, numberOfWords\r\n  this.resultsForRule = function resultsForRule(lhs, start, end) {\r\n    start = start || 0;\r\n    end = end || numberOfWords;\r\n    var results = [];\r\n    var finalEdges = this.passives[start][lhs];\r\n    for (var i in finalEdges) {\r\n      if (finalEdges[i].end == end) {\r\n\tresults.push(finalEdges[i].out);\r\n      }\r\n    }\r\n    return results;\r\n  }\r\n  \r\n  // Chart.allEdges() / Chart.allPassiveEdges() / Chart.allActiveEdges()\r\n  // return an array of all (passive/active) edges in the chart\r\n  this.allEdges = function allEdges() {\r\n    return this.allPassiveEdges().concat(this.allActiveEdges());\r\n  }\r\n  this.allPassiveEdges = function allPassiveEdges() {\r\n    var edges = [];\r\n    for (var i in this.passives) \r\n      for (var j in this.passives[i]) \r\n\tfor (var k in this.passives[i][j])\r\n\t  edges.push(this.passives[i][j][k]);\r\n    return edges;\r\n  }\r\n  this.allActiveEdges = function allActiveEdges() {\r\n    var edges = [];\r\n    for (var i in this.actives) \r\n      for (var j in this.actives[i]) \r\n\tfor (var k in this.actives[i][j])\r\n\t  edges.push(this.actives[i][j][k]);\r\n    return edges;\r\n  }\r\n\r\n  // Chart.statistics()\r\n  // return the number of edges in the chart\r\n  this.statistics = function statistics() {\r\n    var passives = this.allPassiveEdges().length;\r\n    var actives = this.allActiveEdges().length;\r\n    return {nrEdges: passives+actives, nrPassiveEdges: passives, nrActiveEdges: actives};\r\n  }\r\n}\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// parse edges: passive and active\r\n\r\nfunction PassiveEdge(start, end, lhs, out) {\r\n  this.start = start;\r\n  this.end = end;\r\n  this.lhs = lhs;\r\n  this.out = out;\r\n  this.isPassive = true;\r\n\r\n  var str = \"[\" + start + \"-\" + end + \"] $\" + lhs + \" := \" + out;\r\n  this._string = str;\r\n  this.toString = function toString() {return this._string;} \r\n}\r\n\r\nfunction ActiveEdge(start, end, lhs, next, rest, out, rules, text) {\r\n  this.start = start;\r\n  this.end = end;\r\n  this.lhs = lhs;\r\n  this.next = next;\r\n  this.rest = rest;\r\n  this.out = out;\r\n  this.rules = rules;\r\n  this.text = text;\r\n  this.isPassive = false;\r\n\r\n  var str = \"<\" + start + \"-\" + end + \"> $\" + lhs + \" -> \" + next + \r\n    \", \" + rest + \" := \" + out + \" <- \" + rules;\r\n  this._string = str;\r\n  this.toString = function toString() {return this._string;} \r\n}\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// the main parsing function: a simple top-down chartparser\r\n//  - 'words' is an array of strings\r\n//  - 'grammar' is a hash table of left-hand-sides mapping to arrays of right-hand-sides\r\n//  - 'root' is the starting category (a string)\r\n//    if unspecified, use the '$root' property of the grammar\r\n//  - 'filter' is an optional left-corner filter \r\n//    (a mapping from categories/rule-refs to words)\r\n//    if specified, it is used when predicting new edges\r\n// returns the final chart\r\nexport function parse(words, grammar, root, filter) {\r\n  if (!root) {\r\n    root = grammar.$root;\r\n  }\r\n  var chart = new Chart(words.length);\r\n  var agenda = [];\r\n\r\n  var leftCornerFilter;\r\n  if (filter == undefined) {\r\n    leftCornerFilter = function() {return true};\r\n  } else {\r\n    leftCornerFilter = function leftCornerFilter(ruleref, position) {\r\n      var leftCorners = filter[ruleref];\r\n      return leftCorners ? words[position] in leftCorners : true;\r\n    }\r\n  }\r\n  \r\n  // add an edge to the chart and the agenda, if it does not already exist\r\n  function addToChart(inference, start, end, lhs, rhs, out, rules, text) {\r\n    var edge;\r\n    if (rhs.length > 0) {\r\n      var next = rhs[0];\r\n      var rest = rhs.slice(1);\r\n      switch (next.constructor) {\r\n\t\r\n      case Array:\r\n\t// the next symbol is a sequence\r\n\taddToChart(inference+\",SEQUENCE\", start, end, lhs, next.concat(rest), out, rules, text);\r\n\treturn;\r\n\t\r\n      case SRGS.RepeatClass:\r\n\t// the next symbol is a repetition\r\n\tvar min = next.min;\r\n\tvar max = next.max;\r\n\t// skip repeat \r\n\tif (min <= 0) {\r\n\t  addToChart(inference+\",SKIP\", start, end, lhs, rest, out, rules, text);\r\n\t}\r\n\t// repeat \r\n\tif (max > 0) {\r\n\t  var content = next.content;\r\n\t  var rhs = (max==1 ? [content] : [content, SRGS.Repeat(min ? min-1 : min, max-1, content)]);\r\n\t  addToChart(inference+\",REPEAT\", start, end, lhs, rhs.concat(rest), out, rules, text);\r\n\t}\r\n\treturn;\r\n\t\r\n      case SRGS.OneOfClass:\r\n\t// the next symbol is a disjunction\r\n\tvar oneof = next.content;\r\n\tfor (var i in oneof) {\r\n\t  var rhs = oneof[i].concat(rest);\r\n\t  addToChart(inference+\",ONEOF\", start, end, lhs, rhs, out, rules, text);\r\n\t} \r\n\treturn;\r\n\t\r\n      case SRGS.TagClass:\r\n\t// the next symbol is a semantic action\r\n\tout = clone(out);\r\n\trules = clone(rules);\r\n\teval(next.content);\r\n\taddToChart(inference+\",TAG\", start, end, lhs, rest, out, rules, text);\r\n\treturn;\r\n      }\r\n\r\n      edge = new ActiveEdge(start, end, lhs, next, rest, out, rules, text);\r\n    } else {\r\n      edge = new PassiveEdge(start, end, lhs, out);\r\n    }\r\n    \r\n    // try to add the edge; if successful, also add it to the agenda\r\n    if (chart.add(edge)) {\r\n      LOG(\"+ \" + inference + \": \" + edge);\r\n      agenda.push(edge);\r\n    }\r\n  }\r\n  \r\n  // seed the agenda with the starting rule\r\n  addToChart(\"INIT\", 0, 0, root, grammar[root], {}, {}, {});\r\n  \r\n  // main loop\r\n  while (agenda.length > 0) {\r\n    var edge = agenda.pop();\r\n    var start= edge.start;\r\n    var end  = edge.end;\r\n    var lhs  = edge.lhs;\r\n    var next = edge.next;\r\n    LOG(edge);\r\n\r\n    if (edge.isPassive) {\r\n      // combine\r\n      var actives = chart.actives[start][lhs];\r\n      for (var i in actives) {\r\n\tvar active = actives[i];\r\n\tvar rules = clone(active.rules);\r\n\tvar text = active.text;\r\n\ttext[edge.lhs] = words.slice(start, end).join(\" \");\r\n\tif (typeof edge.out == 'object' && isEmpty(edge.out)) {\r\n\t    rules[edge.lhs] = text[edge.lhs];\r\n\t} else {\r\n        rules[edge.lhs] = clone(edge.out);\r\n    }\r\n\taddToChart(\"COMBINE\", active.start, end, active.lhs, active.rest, active.out, rules, text);\r\n      }\r\n\r\n    } else if (next.constructor == SRGS.RefClass) {\r\n      var ref = next.content;\r\n      // combine\r\n      var passives = chart.passives[end][ref];\r\n      for (var i in passives) {\r\n\tvar passive = passives[i];\r\n\tvar rules = clone(edge.rules);\r\n\tvar text = edge.text;\r\n\trules[passive.lhs] = clone(passive.out);\r\n\ttext[passive.lhs] = passive.text;\r\n\taddToChart(\"COMBINE\", start, passive.end, lhs, edge.rest, edge.out, rules, text);\r\n      }\r\n      // predict\r\n      if (ref in grammar) {\r\n\tif (leftCornerFilter(ref, end)) {\r\n\t  addToChart(\"PREDICT\", end, end, ref, grammar[ref], {}, {}, {});\r\n\t}\r\n      }\r\n\r\n    } else if (next == words[end]) {\r\n      // scan\r\n      addToChart(\"SCAN\", start, end+1, lhs, edge.rest, edge.out, edge.rules, edge.text);\r\n    }\r\n  }\r\n\r\n  return chart;\r\n}\r\n\r\n\r\n","import { MachineConfig, send, Action, assign } from \"xstate\";\n\n// SRGS parser and example (logs the results to console on page load)\nimport { loadGrammar } from './runparser'\nimport { parse } from './chartparser'\nimport { grammar } from './grammars/dmHome'\n\n\nfunction say(text: string): Action<SDSContext, SDSEvent> {\n    return send((_context: SDSContext) => ({ type: \"SPEAK\", value: text }))\n}\n\nfunction listen(): Action<SDSContext, SDSEvent> {\n    return send('LISTEN')\n}\n\nfunction parsing(text:string): MachineConfig<SDSContext, any, SDSEvent> {\n    return (parse(text.split(/\\s+/), gram).resultsForRule(gram.$root)[0])\n}\n\nfunction promptAndAsk(prompt: string): MachineConfig<SDSContext, any, SDSEvent> {\n    return ({\n        initial: 'prompt',\n        states: {\n            prompt: {\n                entry: say(prompt),\n                on: { ENDSPEECH: 'ask' }\n            },\n            ask: {\n                entry: listen(),\n            },\n        }\n    })\n}\n\n\nexport const dmMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'init',\n    states: {\n        init: {\n            on: {\n                CLICK: 'welcome'\n            }\n        },\n        welcome: {\n            on: {\n                RECOGNISED: [{\n                    cond: (context) => parsing(context.recResult) !== undefined,\n                    target: \"returnobject\",\n                    actions: assign((context) => { return { option: parsing(context.recResult) } }),\n                },\n                {target: \".nomatch\" }]    \n            },\n                ...promptAndAsk(\"What would you like to do?\")\n        },\n        returnobject: {\n            initial: \"prompt\",\n            on: { ENDSPEECH: \"init\" },\n            states: {\n                prompt: {\n                    entry: send((context) => ({\n                        type: \"SPEAK\",\n                        value: `OK. the object you have chosen is ${context.option.combine.object} and the action you have chosen is ${context.option.combine.action}.`\n                    }))\n                },\n            }\n        },\n        \n    }\n})\n","import \"./styles.scss\";\r\nimport * as React from \"react\";\r\nimport * as ReactDOM from \"react-dom\";\r\nimport { Machine, assign, send, State } from \"xstate\";\r\nimport { useMachine, asEffect } from \"@xstate/react\";\r\nimport { inspect } from \"@xstate/inspect\";\r\nimport { dmMachine } from \"./dmSmartHome\";\r\n\r\n\r\ninspect({\r\n    url: \"https://statecharts.io/inspect\",\r\n    iframe: false\r\n});\r\n\r\nimport { useSpeechSynthesis, useSpeechRecognition } from 'react-speech-kit';\r\n\r\n\r\nconst machine = Machine<SDSContext, any, SDSEvent>({\r\n    id: 'root',\r\n    type: 'parallel',\r\n    states: {\r\n        dm: {\r\n            ...dmMachine\r\n        },\r\n        asrtts: {\r\n            initial: 'idle',\r\n            states: {\r\n                idle: {\r\n                    on: {\r\n                        LISTEN: 'recognising',\r\n                        SPEAK: {\r\n                            target: 'speaking',\r\n                            actions: assign((_context, event) => { return { ttsAgenda: event.value } })\r\n                        }\r\n                    }\r\n                },\r\n                recognising: {\r\n                    initial: 'progress',\r\n                    entry: 'recStart',\r\n                    exit: 'recStop',\r\n                    on: {\r\n                        ASRRESULT: {\r\n                            actions: ['recLogResult',\r\n                                assign((_context, event) => { return { recResult: event.value } })],\r\n                            target: '.match'\r\n                        },\r\n                        RECOGNISED: 'idle'\r\n                    },\r\n                    states: {\r\n                        progress: {\r\n                        },\r\n                        match: {\r\n                            entry: send('RECOGNISED'),\r\n                        },\r\n                    }\r\n                },\r\n                speaking: {\r\n                    entry: 'ttsStart',\r\n                    on: {\r\n                        ENDSPEECH: 'idle',\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    },\r\n},\r\n    {\r\n        actions: {\r\n            recLogResult: (context: SDSContext) => {\r\n                /* context.recResult = event.recResult; */\r\n                console.log('<< ASR: ' + context.recResult);\r\n            },\r\n            test: () => {\r\n                console.log('test')\r\n            },\r\n            logIntent: (context: SDSContext) => {\r\n                /* context.nluData = event.data */\r\n                console.log('<< NLU intent: ' + context.nluData.intent.name)\r\n            }\r\n        },\r\n    });\r\n\r\n\r\n\r\ninterface Props extends React.HTMLAttributes<HTMLElement> {\r\n    state: State<SDSContext, any, any, any>;\r\n}\r\nconst ReactiveButton = (props: Props): JSX.Element => {\r\n    switch (true) {\r\n        case props.state.matches({ asrtts: 'recognising' }):\r\n            return (\r\n                <button type=\"button\" className=\"glow-on-hover\"\r\n                    style={{ animation: \"glowing 20s linear\" }} {...props}>\r\n                    Listening...\r\n                </button>\r\n            );\r\n        case props.state.matches({ asrtts: 'speaking' }):\r\n            return (\r\n                <button type=\"button\" className=\"glow-on-hover\"\r\n                    style={{ animation: \"bordering 1s infinite\" }} {...props}>\r\n                    Speaking...\r\n                </button>\r\n            );\r\n        default:\r\n            return (\r\n                <button type=\"button\" className=\"glow-on-hover\" {...props}>\r\n                    Click to start\r\n                </button >\r\n            );\r\n    }\r\n}\r\n\r\nfunction App() {\r\n    const { speak, cancel, speaking } = useSpeechSynthesis({\r\n        onEnd: () => {\r\n            send('ENDSPEECH');\r\n        },\r\n    });\r\n    const { listen, listening, stop } = useSpeechRecognition({\r\n        onResult: (result: any) => {\r\n            send({ type: \"ASRRESULT\", value: result });\r\n        },\r\n    });\r\n    const [current, send, service] = useMachine(machine, {\r\n        devTools: true,\r\n        actions: {\r\n            recStart: asEffect(() => {\r\n                console.log('Ready to receive a color command.');\r\n                listen({\r\n                    interimResults: false,\r\n                    continuous: true\r\n                });\r\n            }),\r\n            recStop: asEffect(() => {\r\n                console.log('Recognition stopped.');\r\n                stop()\r\n            }),\r\n            changeColour: asEffect((context) => {\r\n                console.log('Repainting...');\r\n                document.body.style.background = context.recResult;\r\n            }),\r\n            ttsStart: asEffect((context, effect) => {\r\n                console.log('Speaking...');\r\n                speak({ text: context.ttsAgenda })\r\n            }),\r\n            ttsCancel: asEffect((context, effect) => {\r\n                console.log('TTS STOP...');\r\n                cancel()\r\n            })\r\n            /* speak: asEffect((context) => {\r\n\t     * console.log('Speaking...');\r\n             *     speak({text: context.ttsAgenda })\r\n             * } */\r\n        }\r\n    });\r\n\r\n\r\n    return (\r\n        <div className=\"App\">\r\n            <ReactiveButton state={current} onClick={() => send('CLICK')} />\r\n        </div>\r\n    )\r\n};\r\n\r\n\r\n\r\n/* RASA API\r\n *  */\r\nconst proxyurl = \"https://cors-anywhere.herokuapp.com/\";\r\nconst rasaurl = 'https://rasa-nlu-api-00.herokuapp.com/model/parse'\r\nconst nluRequest = (text: string) =>\r\n    fetch(new Request(proxyurl + rasaurl, {\r\n        method: 'POST',\r\n        headers: { 'Origin': 'http://maraev.me' }, // only required with proxy\r\n        body: `{\"text\": \"${text}\"}`\r\n    }))\r\n        .then(data => data.json());\r\n\r\nconst rootElement = document.getElementById(\"root\");\r\nReactDOM.render(\r\n    <App />,\r\n    rootElement);\r\n"],"sourceRoot":""}